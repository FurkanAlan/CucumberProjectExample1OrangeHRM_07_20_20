########################### Note 1 ###############################

data provider and data table different types

example for data table:

  Scenario Outline: Invalid login error message validation
    Given I enter username "<username>" and password "<password>"
    When I click login button
    Then I see "<errorMsg>"

    Examples:
      | username | password  | errorMsg                 |
      | Admin    | Qwerty123 | Invalid credentials      |
      | Admin    |           | Password cannot be empty |
      | Admin123 | QWer123   | Invalid credentials      |
      |          | admin123  | Username cannot be empty |
      |          |           | Username cannot be empty |

Data Table ayni zamanda map seklinde de yazilabilir

Seklinde olmali

ancak data provider ise
Excel olabilir yada sql database olabilir, belki JSON dosyasi olabilir



########################### Note 2 ###############################

    public void i_enter_username_and_password_I_see_error_message(io.cucumber.datatable.DataTable dataTable) {
        //list of map
        List<Map<String, String>> maps = dataTable.asMaps();

        //listedeki maps lerin icerisinde iterate edecegiz, listenin icerisi map oldugu icin bu sekilde yapildi
        for (Map<String, String> map : maps) {
            //birincisi WebElementi oluyor ikincisi ise ne gondercegimizi ifade ediyor
            //nereye ne gonderecegimiz seklinde de dusunulebilir
            //gonderecegimiz String ifadesini de olusturdumuz DataTable dan alicagmiz icin
            //gonderecegimiz ifadeler sirasiyla
            //username,  password,   hata mesaji olacak
            //butun key ifadeleri DataTable ile ayni olmak zorunda

            //DataTable in Scenerio Outline dan farkli, DT bir defa Browser Instance aciyor ve testleri bitirireseye
            // kadar loop yapiyor ancak SO ise herbir case icin testi bitiriyor ondan sonra yeni test icin yeniden
            // browser aciyor, yani ozet olarak test bir kere calisiyor DT icin ancak SO icin ise test sayisi kadar
            // test calisiyor

            sendText(login.userName, map.get("username"));
            sendText(login.password, map.get("password"));

            click(login.loginBtn);

            Object key;
            String actualErrorMessage = login.errMsg.getText();
            String expectedErrorMessage = map.get("errorMsg");

            Assert.assertEquals("Error message mismatched", expectedErrorMessage, actualErrorMessage);

        }


        Feature: Negative login test with Excel

          Scenario: Negative Testing With Excel
            When I enter username and password I see error message
              | username | password  | errorMsg                 |
              | Admin    | Qwerty123 | Invalid credentials      |
              | Admin    |           | Password cannot be empty |
              | Admin123 | QWer123   | Invalid credentials      |
              |          | admin123  | Username cannot be empty |
              |          |           | Username cannot be empty |

#################################### 3 ############################################

        Feature: Negative login test with Excel

          Scenario: Negative Testing With Excel
            When I enter username and password I see error message
              | username | password  | errorMsg                 |
              | Admin    | Qwerty123 | Invalid credentials      |

eger bu sekilde data table varse bunu yazabilmek icin Map<String, String yapilir>

        Map<String, String> map = dataTable.asMap ();

        for (String text : map) {

        }

#################################### 4 ############################################

        Feature: Negative login test with Excel

          Scenario: Negative Testing With Excel
            When I enter username and password I see error message
              | Admin    | Qwerty123 | Invalid credentials      |

eger bu sekilde data table varse bunu yazabilmek icin List<String, String yapilir>

        List<String, String> list = dataTable.asList ();

        for (String text : list) {

        }


#################################### 5 ############################################
Scenario outline:
 Example:
      | username | password  | errorMsg                 |
      | Admin    | Qwerty123 | Invalid credentials      |
      | Admin    |           | Password cannot be empty |
      | Admin123 | QWer123   | Invalid credentials      |
      |          | admin123  | Username cannot be empty |
      |          |           | Username cannot be empty |


Data Table lari Ozet olarak yapacak olursak

import io.cucumber.datatable.DataTable;

dan geliyor DataTable

1-)  DataTable With Header And Multiple Data Row

Feature: Negative login test with Excel
          Scenario:
              | username | password  | errorMsg                 |
              | Admin    | Qwerty123 | Invalid credentials      |
              | Admin    |           | Password cannot be empty |
              | Admin123 | QWer123   | Invalid credentials      |
              |          | admin123  | Username cannot be empty |
              |          |           | Username cannot be empty |


 List<Map<String, String>> maps = dataTable.asMaps();

         for (Map<String, String> map : maps) {
         }

2-) DataTable With Header And Single Data Row

Feature:
          Scenario:
              | username | password  | errorMsg                 |
              | Admin    | Qwerty123 | Invalid credentials      |



 Map<String, String> map = dataTable.asMap();

Belki boyle
         for (String text : map) {
         }

yada boyle

         for (Map<String, String>  : map) {
         }


3-)  DataTable Without Header And Multiple Data Row

Feature:
          Scenario:
              | Admin    | Qwerty123 | Invalid credentials      |
              | Admin    |           | Password cannot be empty |
              | Admin123 | QWer123   | Invalid credentials      |
              |          | admin123  | Username cannot be empty |
              |          |           | Username cannot be empty |


 List<List<String>> lists = dataTable.asLists();

         for (List<String> list : lists) {
         }



4-) DataTable Without Header And Single Data Row

Feature:
          Scenario:
              | Admin    | Qwerty123 | Invalid credentials      |


 List<String> list = dataTable.asList();

         for (String string : list) {
         }

Scenario Outline ila DataTable arasindaki en buyuk fark, Outline broser i kapatim aciyor lakin DataTable bir defa aciyor
 tum metodlari calisitiriyor, veya dongu yapiyor
################################################################################

##################################### 6 ###########################################
sendText() metodu CommonMetods da tanimli
Buradaki, username, password DataTable olan headerlar ve ayni olmak zorunda

1-) DataTable With Header And Multiple Data Row

 List<Map<String, String>> maps = dataTable.asMaps();

         for (Map<String, String> map : maps) {
            sendText(login.userName, map.get("username"));
            sendText(login.password, map.get("password"));

            click(login.loginBtn);

            String actualErrorMessage = login.errMsg.getText();
            String expectedErrorMessage = map.get("errorMsg");
         }

3-)  DataTable Without Header And Multiple Data Row
Buradaki get(0) = username, get(1) = password, get(2) = errorMsg
manasina geliyor

List<List<String>> lists = dataTableNoHeader.asLists();

        for (List<String> list : lists) {
            sendText(login.userName, list.get(0));
            sendText(login.password, list.get(1));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            click(login.loginBtn);

            String actualErrorMessage = login.errMsg.getText();
            String expectedErrorMessage = list.get(2);

            Assert.assertEquals("Someting went wrong", expectedErrorMessage, actualErrorMessage);



################################################################################

##################################### 7 Excel den data okuma With Header ###########################################

Excel data cekmek icin asMaps(), eger baslik varsa = K-V cifleri seklinde    yada asLists(), eger baslik yoksa = data
lar ,  seklinde dusunulebilir

Kullanilan metod asagida verildi
Eger excel dosaymida baslik bilgilseri varsa Maps yada Map olarak dusunmeliyiz
Buda Key, Value deger ciftleri olarak calisiyor

List<Map<String, String>> data=new ArrayList<Map<String, String>>();

Bu ifadenin manasi, Excel de bulunan, ifade ciftlerini K = header, V = degerler seklinde cifler olarak dusunulebilir
Aslinda digeriyle DataTable ile ayni mantikda calisiyor

firstName	middleName	lastName	userName	                password
George	        G	      Hagi	     ghagi@gmail.com	        gHagi123-=
Michael	        M	      Owen	     mowen@gmail.com	        mOwen123-=
Donald	        D	      Trump	     dtrump@gmail.com	        dTrump123-=
Gokhan	        Hasan	  Sas	     ghsas@gmail.com	        ghSas123-=
Hakan	        H	      Sukur	     hsukur@gmail.com	        hSukur123-=
James	        Jame	  Jones	     jjjones@gmail.com	        jjJones123-=


for(int i=1; i<rowCount(); i++) {   ==>  Bu satirlara tekabul ediyor

}

Buradaki i = 1 in manasi, header i atla ikinci satirdan baslat, tabi bu excel de baslik varsa dogru oluyor

Map<String, String> map=new HashMap<>();
Bu ifadenin manasi ise, Herbir Satir icin bir map olusturacagiz ve bu map i listemize ekleyecegiz

Herbir satirda yeni bir map olusturacagiz, ve bu map icerisinde o satirdaki bilgileri koyduktan sonrna
bunu listemize ilave edecegiz

Her bir satiri tariyacagiz ve bu satirlardaki degerleri map degiskenine yerlestiriyoruz


Birinci data cifti
1-)
firstName	middleName	lastName	userName	                password   ======>  Key
George	        G	      Hagi	     ghagi@gmail.com	        gHagi123-= ======> Value

2-)
firstName	middleName	lastName	userName	                password   ======>  Key
Michael	        M	      Owen	     mowen@gmail.com	        mOwen123-= ======> Value

3-)
firstName	middleName	lastName	userName	                password     ======>  Key
Donald	        D	      Trump	     dtrump@gmail.com	        dTrump123-=  ======> Value

4-)
firstName	middleName	lastName	userName	                password     ======>  Key
Gokhan	        Hasan	  Sas	     ghsas@gmail.com	        ghSas123-=   ======> Value


5-)
firstName	middleName	lastName	userName	                password       ======>  Key
James	        Jame	  Jones	     jjjones@gmail.com	        jjJones123-=   ======> Value




for(int j=0; j<colCount(); j++) {

}

burada j = 0 ise sutun a karsilik geliyor, aslinda bunu 2D array gibi dusunmek lazim,

i = 0 lar Key lere tekabul ediyor

i = 1 ve j = 0 ise degerlere karsilik geliyor,
    ---------------
i=0 | K    | K    |
    --------------
i=1 | j=0  | j=1  |
    --------------
i=2 | j=0  | j=1  |
    ---------------

Bu sekilde tum degerleri taramis oluyoruz

for(int i=1; i<rowCount(); i++) {
    for(int j=0; j<colCount(); j++) {

    }
}

map.put(Key, Value);
map.put(getCellData(0, j), getCellData(i, j));

getCellData(0, j)  =  Key,   0. satirdaki degisen sutun degerleri demek
getCellData(i, j)  =  Value  bu ifade de onlara karislik gelen degerler demek,

i = 1,  j = 0
ornek olarak, (1,0),  birinci satirdaki 0. sutun degeri

i = 1,  j = 1
ornek olarak, (1,1),  birinci satirdaki 1. sutun degeri,
seklinde tum degerleri tariyor


en son olarak da map deki degerleri data ya ekle

data.add(map);

ve onlari return yap demek oluyor

return data;


    public static List<Map<String, String>> excelIntoListOfMaps(String filePath, String sheetName){
        openExcel(filePath, sheetName);

        List<Map<String, String>> data=new ArrayList<Map<String, String>>();

        for(int i=1; i<rowCount(); i++) {
            Map<String, String> map=new HashMap<>();
            for(int j=0; j<colCount(); j++) {
                map.put(getCellData(0, j), getCellData(i, j));
            }
            data.add(map);
        }
        return data;
    }




################################################################################

##################################### 8 Excel den data okuma No Header ###########################################

Mantik digeriyle aynni oluyor buradaki fark Key degerleri yok

List<List<String>> data=new ArrayList<>();

George	        G	      Hagi	     ghagi@gmail.com	        gHagi123-=
Michael	        M	      Owen	     mowen@gmail.com	        mOwen123-=
Donald	        D	      Trump	     dtrump@gmail.com	        dTrump123-=
Gokhan	        Hasan	  Sas	     ghsas@gmail.com	        ghSas123-=
Hakan	        H	      Sukur	     hsukur@gmail.com	        hSukur123-=
James	        Jame	  Jones	     jjjones@gmail.com	        jjJones123-=

buradaki herbir satir ArrayList in icerisne atiliyor, malum ArrayList dyanmic oldugu icin bunu yapabiliyrouz


for(int i=0; i<rowCount(); i++) {  ==> satir bilgileri icinn
}

i = 0 dan baslattik cunku burada satir bilgisi yok

Ancak bizdeki excel dosyasinda bu Sheet name => addEmp1  ila test yapiyoruz ve bunun ilk satirinda
firstName	middleName	lastName	userName	                password
tanimli oldugu icin

for(int i=1; i<rowCount(); i++) {  ==>  i = 1 den baslatilmis
}

List<String> list=new ArrayList<>();

Tum degerlerimizi list emize ekleyecegiz
Herbir satirda bu listeyi tekrar tanimlayip icerisindeki degerleri alip, diger bir list in
icersine kaydetmemiz lazim


for(int j=0; j<colCount(); j++) {  ==> sutun bilgileri icin

}
List<String> list, burada tanimladiigmiz list icerisne ilgili satirdaki degerleri kaydediyoruz
ve bu degerleri kaydetmek icin de;

list.add(getCellData(i, j));

add()   map deki muadili  ==> put(K, V);  oluyor, ve degeleri kaydetmek icin metodlarini kullaniyoruz

getCellData(i, j)    ==>  put(getCellData(0, j), getCellData(i, j));

icdeki bir satirdaki degerleri bir, List<String> list, olarak kaydediyor

data.add(list);

daha sonra bunu da data ya kaydediyoruz


return data;

yaparak data cagirmis oluyoruz



    public static List<List<String>> excelIntoListOfList(String filePath, String sheetName){
        openExcel(filePath, sheetName);
        List<List<String>> data=new ArrayList<>();

        for(int i=0; i<rowCount(); i++) {
            List<String> list=new ArrayList<>();
            for(int j=0; j<colCount(); j++) {
                list.add(getCellData(i, j));
            }
            data.add(list);
        }

        return data;
    }

